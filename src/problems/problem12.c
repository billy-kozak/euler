/******************************************************************************
* The sequence of triangle numbers is generated by adding the natural         *
* numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 =    *
* 28. The first ten terms would be:                                           *
*                                                                             *
* 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...                                    *
*                                                                             *
* Let us list the factors of the first seven triangle numbers:                *
*                                                                             *
*      1: 1                                                                   *
*      3: 1,3                                                                 *
*      6: 1,2,3,6                                                             *
*     10: 1,2,5,10                                                            *
*     15: 1,3,5,15                                                            *
*     21: 1,3,7,21                                                            *
*     28: 1,2,4,7,14,28                                                       *
*                                                                             *
* We can see that 28 is the first triangle number to have over five divisors. *
*                                                                             *
* What is the value of the first triangle number to have over five hundred    *
* divisors?                                                                   *
******************************************************************************/
/******************************************************************************
*                                  INCLUDES                                   *
******************************************************************************/
#include "eulerProblems.h"
#include "eulerSolvers.h"

#include "primeGeneration.h"
#include "simpleMath.h"

#include <assert.h>
/******************************************************************************
*                                    TYPES                                    *
******************************************************************************/
struct primeCount{
	unsigned primes;
	unsigned primePowers;
};
/******************************************************************************
*                                   DEINFES                                   *
******************************************************************************/
#define PROBLEM12_MAGIC 500
/******************************************************************************
*                             FUNCTION PROTOTYPES                             *
******************************************************************************/
static struct primeCount countPrimeFactors(
		struct trialPrimeGen* gen, unsigned n
	);
static unsigned divCount(unsigned n, unsigned b,unsigned d);
/******************************************************************************
*                            FUNCTION DEFINITIONS                             *
******************************************************************************/
/**
*
*
* TODO - handle possible memory error
**/
static struct primeCount countPrimeFactors(
		struct trialPrimeGen* gen, unsigned n
	){
	struct primeCount counts = {0,0};
	unsigned root = gteSquareRoot(n);
	unsigned prime;
	unsigned pInd = 0;

	if(!gen->v->len){

		prime = trailDivideGenNext(gen);
	}

	do{
		pInd += 1;

		if(!(n%prime)){
			//note that we know that this won't overflow because
			//we are less than the square root of n
			unsigned power = prime*prime;
			counts.primes += 1;
			counts.primePowers += divCount(n,prime,power);
		}

		if(pInd >= gen->v->len){
			prime = trailDivideGenNext(gen);
		}
		else{
			prime = w1vect_getIndUnsigned(gen->v,pInd);
		}

	}while(prime <= root);

	return counts;
}
/**
*
**/
static unsigned divCount(unsigned n, unsigned b, unsigned d){
	unsigned count = 0;
	unsigned last = b;
	unsigned next = last;

	do{
		if(n%next){
			break;
		}

		count += 1;

		if(umul_overflow(last,d,&next)){
			//overflow occured
			return count;
		}

		last = next;
	}while(next <= n);

	return count;
}
/**
* Solution for problem 12
**/
struct eulerSol euler_prob12(void){
	struct eulerSol sol = {U64};

	return sol;
}
